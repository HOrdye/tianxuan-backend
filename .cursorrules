# 后端API开发Cursor Rules

## 📋 架构规范
- 三层架构：Controller → Service → Database
- 文件命名：kebab-case（如 `checkin.service.ts`）
- 函数命名：camelCase（如 `dailyCheckIn`）
- 类型命名：PascalCase（如 `CheckInResult`）

## 🔌 API开发规范

### 路径和参数
- ✅ 必须对照前端需求文档，API路径完全一致（大小写、单复数）
- ✅ 参数兼容：同时支持camelCase和snake_case
- ✅ 响应格式：字段名、数据结构与前端期望完全匹配

### 响应格式
- ✅ 必须使用 `sendSuccess()` 和 `sendError()` 统一响应
- ✅ 成功：`{ success: true, data: {...}, message?: string }`
- ✅ 错误：`{ success: false, error: string, message?: string }`

### 错误处理
- ✅ 使用统一错误函数：`sendBadRequest`, `sendUnauthorized`, `sendNotFound`, `sendInternalError`
- ✅ 记录详细日志：包含userId、orderId等上下文
- ✅ 根据错误类型返回合适HTTP状态码

### 参数验证
- ✅ 所有输入参数必须验证（必填、类型、范围）
- ✅ 验证失败立即返回，不继续执行
- ✅ 返回友好错误消息

### 认证和权限
- ✅ 需要认证的API使用 `authenticateToken` 中间件
- ✅ 用户隔离：确保用户只能访问自己的数据
- ✅ 管理员API调用 `is_admin()` 验证

## 🗄️ 数据库操作规范

### 事务处理
- ✅ 关键操作必须使用事务（支付、扣费、签到、订阅）
- ✅ 使用同一个client，事务中必须用同一个连接
- ✅ catch中执行ROLLBACK，finally中释放连接

### 并发安全
- ✅ 使用 `FOR UPDATE` 锁定行，防止并发修改
- ✅ 幂等性检查：支付、签到等操作支持重复调用
- ✅ 利用数据库唯一约束防止重复数据

### 时区处理
- ✅ 日期比较使用 `CURRENT_DATE`（PostgreSQL服务器时区）
- ✅ 不要在JavaScript中计算日期，使用数据库函数
- ✅ 返回前端时统一格式化为 `YYYY-MM-DD`

### 参数化查询
- ✅ 必须使用参数化查询防止SQL注入
- ✅ 日期类型使用 `::date` 显式转换
- ✅ 使用 `COALESCE` 处理可选参数

## 🐛 调试和日志
- ✅ 关键业务逻辑添加结构化日志（对象格式）
- ✅ 错误日志包含上下文（userId、orderId等）
- ✅ 记录验证失败原因和默认值使用

## 🔒 业务逻辑规范
- ✅ 幂等性：支付回调、签到操作必须支持重复调用
- ✅ 数据一致性：优先使用数据库函数（已包含事务和锁）
- ✅ 类型安全：定义TypeScript接口，避免any类型

## 📝 代码质量
- ✅ 导出函数必须有JSDoc注释
- ✅ 复杂业务逻辑添加注释说明
- ✅ try-catch覆盖所有可能出错的操作
- ✅ 根据错误类型（数据库错误、业务错误）分别处理

## 🚨 常见错误避免
1. API路径不一致 → 对照前端需求文档
2. 参数命名不一致 → 同时支持两种命名
3. 响应格式不一致 → 使用 `sendSuccess()` 统一格式
4. 时区问题 → 使用数据库 `CURRENT_DATE`
5. 事务使用错误 → 事务中使用同一个client
6. 缺少幂等性检查 → 检查状态，已处理直接返回
7. 缺少参数验证 → 验证所有输入参数
8. 缺少权限验证 → 验证用户权限，确保数据隔离

## 📋 开发检查清单
- [ ] API路径与前端完全一致
- [ ] 参数兼容（camelCase和snake_case）
- [ ] 响应格式使用 `sendSuccess` 统一格式
- [ ] 所有错误都有合适的处理
- [ ] 关键操作有日志记录
- [ ] 关键操作使用事务
- [ ] 幂等性检查已实现

## 📚 参考文档
- `260130-前端转后端API需求映射表.md`
- `后端API开发提示词-任务系统.md`
- `紫微斗数API开发规范.md`
- `支付API实现说明.md`
