# ç”¨æˆ·æ•°å­—å­ªç”Ÿç³»ç»Ÿ - æ•°æ®åº“è¿ç§»è„šæœ¬

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
**åˆ›å»ºæ—¥æœŸ**ï¼š2026-01-31  
**æ•°æ®åº“**ï¼šPostgreSQL

---

## ğŸ“‹ è¿ç§»è„šæœ¬

### 1. æ·»åŠ  implicit_traits å­—æ®µ

```sql
-- æ£€æŸ¥å¹¶æ·»åŠ  implicit_traits å­—æ®µï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'profiles' AND column_name = 'implicit_traits'
    ) THEN
        ALTER TABLE profiles 
        ADD COLUMN implicit_traits JSONB DEFAULT '{}'::jsonb;
        
        -- æ·»åŠ æ³¨é‡Š
        COMMENT ON COLUMN profiles.implicit_traits IS 'ç”¨æˆ·éšæ€§ç‰¹å¾ï¼ˆè‡ªåŠ¨æå–ï¼‰ï¼šè§’è‰²ã€å…´è¶£ã€é£é™©åå¥½ç­‰';
    END IF;
END $$;
```

### 2. åˆ›å»º GIN ç´¢å¼•ï¼ˆä¼˜åŒ–JSONBæŸ¥è¯¢ï¼‰

```sql
-- ä¸º preferences å­—æ®µåˆ›å»º GIN ç´¢å¼•ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
CREATE INDEX IF NOT EXISTS idx_profiles_preferences_gin 
ON profiles USING GIN (preferences);

-- ä¸º implicit_traits å­—æ®µåˆ›å»º GIN ç´¢å¼•ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
CREATE INDEX IF NOT EXISTS idx_profiles_implicit_traits_gin 
ON profiles USING GIN (implicit_traits);
```

### 3. åˆ›å»ºç”Ÿè¾°ä¿¡æ¯åŒæ­¥è§¦å‘å™¨ï¼ˆé˜²å¾¡æ€§ç¼–ç¨‹ + æ—¶åŒºç»Ÿä¸€ï¼‰

```sql
-- åˆ›å»ºå‡½æ•°ï¼šåŒæ­¥ç”Ÿè¾°åˆ° userContextï¼ˆé˜²å¾¡æ€§ç¼–ç¨‹ç‰ˆæœ¬ï¼‰
CREATE OR REPLACE FUNCTION sync_birthday_to_user_context()
RETURNS TRIGGER AS $$
DECLARE
    current_user_context JSONB;
    birth_date_str TEXT;
BEGIN
    -- å¦‚æœ birth_date å‘ç”Ÿå˜åŒ–
    IF NEW.birth_date IS DISTINCT FROM OLD.birth_date THEN
        -- è·å–ç°æœ‰çš„ userContext
        current_user_context := COALESCE(NEW.preferences->'userContext', '{}'::jsonb);
        
        -- ç»Ÿä¸€æ—¶åŒºå¤„ç†ï¼šè½¬æ¢ä¸º ISO8601 å­—ç¬¦ä¸²ï¼ˆUTCï¼‰
        -- ç¡®ä¿ birth_date (Dateç±»å‹) å’Œ JSON ä¸­çš„å­—ç¬¦ä¸²æ ¼å¼æ—¥æœŸåœ¨æ—¶åŒºå¤„ç†ä¸Šä¸€è‡´
        birth_date_str := to_char(NEW.birth_date, 'YYYY-MM-DD');
        
        -- æ›´æ–° userContextï¼Œæ·»åŠ  birthDateï¼ˆå¦‚æœä¸å­˜åœ¨æˆ–éœ€è¦æ›´æ–°ï¼‰
        IF current_user_context->>'birthDate' IS NULL OR 
           current_user_context->>'birthDate' != birth_date_str THEN
            current_user_context := current_user_context || jsonb_build_object(
                'birthDate', birth_date_str
            );
            
            -- æ›´æ–° preferences
            NEW.preferences := COALESCE(NEW.preferences, '{}'::jsonb) || 
                jsonb_build_object('userContext', current_user_context);
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºè§¦å‘å™¨
DROP TRIGGER IF EXISTS trigger_sync_birthday_to_user_context ON profiles;
CREATE TRIGGER trigger_sync_birthday_to_user_context
BEFORE UPDATE ON profiles
FOR EACH ROW
WHEN (NEW.birth_date IS DISTINCT FROM OLD.birth_date)
EXECUTE FUNCTION sync_birthday_to_user_context();
```

### 4. åˆ›å»ºå®Œæ•´åº¦è®¡ç®—å‡½æ•°

```sql
-- åˆ›å»ºå‡½æ•°ï¼šè®¡ç®—èµ„æ–™å®Œæ•´åº¦
CREATE OR REPLACE FUNCTION calculate_completeness(
    p_preferences JSONB,
    p_birth_date DATE
)
RETURNS INTEGER AS $$
DECLARE
    score INTEGER := 0;
    user_context JSONB;
BEGIN
    -- è·å– userContext
    user_context := COALESCE(p_preferences->'userContext', '{}'::jsonb);
    
    -- åŸºçŸ³å±‚ï¼ˆ40åˆ†ï¼‰ï¼šç”Ÿè¾°ä¿¡æ¯
    IF p_birth_date IS NOT NULL THEN
        score := score + 40;
    END IF;
    
    -- æ˜¾æ€§å±‚ï¼ˆ60åˆ†ï¼‰
    -- MBTIï¼ˆ10åˆ†ï¼‰
    IF user_context->>'mbti' IS NOT NULL AND user_context->>'mbti' != '' THEN
        score := score + 10;
    END IF;
    
    -- èŒä¸šï¼ˆ10åˆ†ï¼‰
    IF user_context->>'profession' IS NOT NULL AND user_context->>'profession' != '' THEN
        score := score + 10;
    END IF;
    
    -- ç°çŠ¶ï¼ˆ20åˆ†ï¼‰
    IF user_context->>'currentStatus' IS NOT NULL AND user_context->>'currentStatus' != '' THEN
        score := score + 20;
    END IF;
    
    -- æ„¿æ™¯ï¼ˆ20åˆ†ï¼‰
    IF user_context->'wishes' IS NOT NULL AND jsonb_array_length(user_context->'wishes') > 0 THEN
        score := score + 20;
    END IF;
    
    -- ç¡®ä¿ä¸è¶…è¿‡100åˆ†
    RETURN LEAST(score, 100);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- åˆ›å»ºç´¢å¼•å‡½æ•°ï¼ˆç”¨äºæŸ¥è¯¢ä¼˜åŒ–ï¼‰
CREATE INDEX IF NOT EXISTS idx_profiles_completeness 
ON profiles (calculate_completeness(preferences, birth_date));
```

### 5. æ•°æ®è¿ç§»ï¼šåˆå§‹åŒ–ç°æœ‰ç”¨æˆ·çš„ userContext

```sql
-- ä¸ºç°æœ‰ç”¨æˆ·åˆå§‹åŒ– userContextï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
UPDATE profiles
SET preferences = COALESCE(preferences, '{}'::jsonb) || 
    jsonb_build_object('userContext', '{}'::jsonb)
WHERE preferences->'userContext' IS NULL;

-- ä¸ºæœ‰ç”Ÿè¾°ä¿¡æ¯çš„ç”¨æˆ·åŒæ­¥åˆ° userContext
UPDATE profiles
SET preferences = preferences || jsonb_build_object(
    'userContext',
    COALESCE(preferences->'userContext', '{}'::jsonb) || 
    jsonb_build_object('birthDate', birth_date::text)
)
WHERE birth_date IS NOT NULL 
  AND (preferences->'userContext'->>'birthDate' IS NULL 
       OR preferences->'userContext'->>'birthDate' = '');
```

### 6. åˆ›å»ºå¥–åŠ±è®°å½•è¡¨ï¼ˆå¯é€‰ï¼Œç”¨äºé˜²æ­¢é‡å¤å‘æ”¾ï¼‰

```sql
-- åˆ›å»ºå¥–åŠ±è®°å½•è¡¨ï¼ˆç”¨äºé˜²æ­¢é‡å¤å‘æ”¾ï¼‰
CREATE TABLE IF NOT EXISTS completeness_rewards (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    reward_type VARCHAR(50) NOT NULL, -- 'field_reward' | 'threshold_reward'
    reward_field VARCHAR(50), -- å­—æ®µåï¼ˆfield_rewardæ—¶ä½¿ç”¨ï¼‰
    reward_threshold INTEGER, -- é˜ˆå€¼ï¼ˆthreshold_rewardæ—¶ä½¿ç”¨ï¼‰
    coins INTEGER NOT NULL,
    reason VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- å”¯ä¸€çº¦æŸï¼šé˜²æ­¢é‡å¤å‘æ”¾
    UNIQUE(user_id, reward_type, reward_field, reward_threshold)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_completeness_rewards_user_id 
ON completeness_rewards(user_id);

CREATE INDEX IF NOT EXISTS idx_completeness_rewards_created_at 
ON completeness_rewards(created_at);
```

---

## ğŸ” éªŒè¯æŸ¥è¯¢

### 1. æ£€æŸ¥å­—æ®µæ˜¯å¦å­˜åœ¨

```sql
-- æ£€æŸ¥ implicit_traits å­—æ®µ
SELECT column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'profiles' AND column_name = 'implicit_traits';

-- æ£€æŸ¥ç´¢å¼•
SELECT indexname, indexdef 
FROM pg_indexes 
WHERE tablename = 'profiles' 
  AND indexname LIKE '%preferences%' OR indexname LIKE '%implicit%';
```

### 2. æ£€æŸ¥è§¦å‘å™¨

```sql
-- æ£€æŸ¥è§¦å‘å™¨
SELECT trigger_name, event_manipulation, event_object_table, action_statement
FROM information_schema.triggers
WHERE event_object_table = 'profiles'
  AND trigger_name = 'trigger_sync_birthday_to_user_context';
```

### 3. æµ‹è¯•å®Œæ•´åº¦è®¡ç®—

```sql
-- æµ‹è¯•å®Œæ•´åº¦è®¡ç®—å‡½æ•°
SELECT 
    id,
    username,
    birth_date,
    preferences->'userContext' as user_context,
    calculate_completeness(preferences, birth_date) as completeness
FROM profiles
LIMIT 10;
```

### 4. æ£€æŸ¥æ•°æ®è¿ç§»ç»“æœ

```sql
-- æ£€æŸ¥ userContext åˆå§‹åŒ–æƒ…å†µ
SELECT 
    COUNT(*) as total_users,
    COUNT(preferences->'userContext') as has_user_context,
    COUNT(CASE WHEN preferences->'userContext'->>'birthDate' IS NOT NULL THEN 1 END) as has_birth_date_in_context
FROM profiles;

-- æ£€æŸ¥éšæ€§ä¿¡æ¯å­—æ®µ
SELECT 
    COUNT(*) as total_users,
    COUNT(implicit_traits) as has_implicit_traits,
    COUNT(CASE WHEN implicit_traits != '{}'::jsonb THEN 1 END) as has_data
FROM profiles;
```

---

## ğŸ”„ å›æ»šè„šæœ¬

å¦‚æœéœ€è¦å›æ»šï¼Œæ‰§è¡Œä»¥ä¸‹è„šæœ¬ï¼š

```sql
-- 1. åˆ é™¤è§¦å‘å™¨
DROP TRIGGER IF EXISTS trigger_sync_birthday_to_user_context ON profiles;

-- 2. åˆ é™¤å‡½æ•°
DROP FUNCTION IF EXISTS sync_birthday_to_user_context();
DROP FUNCTION IF EXISTS calculate_completeness(JSONB, DATE);

-- 3. åˆ é™¤ç´¢å¼•
DROP INDEX IF EXISTS idx_profiles_preferences_gin;
DROP INDEX IF EXISTS idx_profiles_implicit_traits_gin;
DROP INDEX IF EXISTS idx_profiles_completeness;

-- 4. åˆ é™¤å­—æ®µï¼ˆè°¨æ…æ“ä½œï¼Œä¼šä¸¢å¤±æ•°æ®ï¼‰
-- ALTER TABLE profiles DROP COLUMN IF EXISTS implicit_traits;

-- 5. åˆ é™¤å¥–åŠ±è®°å½•è¡¨ï¼ˆå¦‚æœåˆ›å»ºäº†ï¼‰
-- DROP TABLE IF EXISTS completeness_rewards;
```

---

## ğŸ“Š æ•°æ®ç»Ÿè®¡æŸ¥è¯¢

### 1. èµ„æ–™å®Œæ•´åº¦åˆ†å¸ƒ

```sql
SELECT 
    CASE 
        WHEN completeness < 30 THEN '0-29'
        WHEN completeness < 50 THEN '30-49'
        WHEN completeness < 70 THEN '50-69'
        WHEN completeness < 100 THEN '70-99'
        ELSE '100'
    END as completeness_range,
    COUNT(*) as user_count
FROM (
    SELECT 
        id,
        calculate_completeness(preferences, birth_date) as completeness
    FROM profiles
) sub
GROUP BY completeness_range
ORDER BY completeness_range;
```

### 2. å‘½ä¸»ååˆºå¡«å†™æƒ…å†µ

```sql
SELECT 
    COUNT(*) as total_users,
    COUNT(CASE WHEN preferences->'userContext'->>'mbti' IS NOT NULL THEN 1 END) as has_mbti,
    COUNT(CASE WHEN preferences->'userContext'->>'profession' IS NOT NULL THEN 1 END) as has_profession,
    COUNT(CASE WHEN preferences->'userContext'->>'currentStatus' IS NOT NULL THEN 1 END) as has_status,
    COUNT(CASE WHEN preferences->'userContext'->>'wishes' IS NOT NULL THEN 1 END) as has_wishes
FROM profiles;
```

### 3. éšæ€§ä¿¡æ¯ç»Ÿè®¡

```sql
SELECT 
    COUNT(*) as total_users,
    COUNT(CASE WHEN implicit_traits->'inferred_roles' IS NOT NULL THEN 1 END) as has_roles,
    COUNT(CASE WHEN implicit_traits->'interest_tags' IS NOT NULL THEN 1 END) as has_interests,
    COUNT(CASE WHEN implicit_traits->>'risk_tolerance' IS NOT NULL THEN 1 END) as has_risk_tolerance
FROM profiles;
```

---

## âœ… è¿ç§»æ£€æŸ¥æ¸…å•

- [ ] æ‰§è¡Œå­—æ®µæ·»åŠ è„šæœ¬
- [ ] æ‰§è¡Œç´¢å¼•åˆ›å»ºè„šæœ¬
- [ ] æ‰§è¡Œè§¦å‘å™¨åˆ›å»ºè„šæœ¬
- [ ] æ‰§è¡Œå‡½æ•°åˆ›å»ºè„šæœ¬
- [ ] æ‰§è¡Œæ•°æ®è¿ç§»è„šæœ¬
- [ ] éªŒè¯å­—æ®µå­˜åœ¨
- [ ] éªŒè¯ç´¢å¼•å­˜åœ¨
- [ ] éªŒè¯è§¦å‘å™¨å­˜åœ¨
- [ ] æµ‹è¯•å®Œæ•´åº¦è®¡ç®—å‡½æ•°
- [ ] æµ‹è¯•ç”Ÿè¾°ä¿¡æ¯åŒæ­¥è§¦å‘å™¨
- [ ] æ£€æŸ¥æ•°æ®è¿ç§»ç»“æœ
- [ ] è¿è¡Œæ•°æ®ç»Ÿè®¡æŸ¥è¯¢

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [ç”¨æˆ·æ•°å­—å­ªç”Ÿç³»ç»Ÿ-åç«¯å¼€å‘æŒ‡å—](./ç”¨æˆ·æ•°å­—å­ªç”Ÿç³»ç»Ÿ-åç«¯å¼€å‘æŒ‡å—.md)
- [ç”¨æˆ·æ•°å­—å­ªç”Ÿç³»ç»Ÿ-APIæ¥å£è§„èŒƒ](./ç”¨æˆ·æ•°å­—å­ªç”Ÿç³»ç»Ÿ-APIæ¥å£è§„èŒƒ.md)

---

## ğŸ”„ æ›´æ–°æ—¥å¿—

- **2026-01-31**ï¼šåˆ›å»ºåˆå§‹æ•°æ®åº“è¿ç§»è„šæœ¬æ–‡æ¡£
